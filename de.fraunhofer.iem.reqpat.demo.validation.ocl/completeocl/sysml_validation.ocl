/*
 * @author fkl-rt, $LastChangedBy: fkl $
 * @version $Rev: 291 $, $Date: 2016-06-28 16:11:43 +0200 (Di, 28 Jun 2016) $
 */
import uml : 'http://www.eclipse.org/uml2/5.0.0/UML'
import SysML : 'http://www.eclipse.org/papyrus/sysml/1.4/SysML' /**/

package uml

context Model

def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

def: setToString(s : Set(NamedElement)) : String
	= replaceSetStrings(s.name->asSet()->toString().replaceFirst('Set', ''))
def: replaceSetStrings(s : String) : String
	= s.substring(2,s.size()).replaceFirst('}', '')

/* Functional devices */
inv TestHasFunctionalPorts('The top-level function ' + Model::setToString(Class::getTopLevel) + ' does not contain corresponding ports to all ports of the functional devices.')
	: Model::getFunctionalDevices.ownedPort()
		->select(p : Port | Class::getTopLevel.ownedPort().name->excludes(p.name))
			->isEmpty()
			
def: getFunctionalDevices : Set(Class)
	= Class::getAllClasses
		->select(c : Class | 
			c.ownedAttribute
				->select(prop | prop.aggregation = AggregationKind::none 
					or (not prop.oclIsTypeOf(Port) and prop.aggregation = AggregationKind::composite)
				)->isEmpty()
		)
	
def: matchingPorts(portToMatch : Port) : Sequence(Port) = Class::getTopLevel.ownedPort()->select(p : Port | p.name=portToMatch.name)->asSequence()
def: getMatchingPort(portToMatch : Port) : Port
	= if matchingPorts(portToMatch)->notEmpty()
		then matchingPorts(portToMatch)->first()
		else null
	endif
		
def: getFuncPortsInSameDirection : Set(Port)
	= Model::getFunctionalDevices.ownedPort()
		->select(p : Port | getMatchingPort(p) <> null and getMatchingPort(p).isConjugated = p.isConjugated)->asSet()
		
inv TestFuncPortsDirectionMatching('The ports ' + setToString(getFuncPortsInSameDirection) 
	+ ' do not have consistent directions on the functional device and on the top-level function '+ Model::setToString(Class::getTopLevel) + '!'
)
	: asError(getFuncPortsInSameDirection->isEmpty())

inv HasFunctionalDevices('There are no functional devices defined.')
	: getFunctionalDevices->notEmpty()

context Class

/* Returns true if a class has not to be checked (e.g. if it's not a Function) */
def: hasNotToBeChecked(c : Class) : Boolean
	= c.getAppliedStereotype('CONSENS::Function') = null

def: getAllClasses : Set(Class)
	= Class.allInstances()->select(c | hasNotToBeChecked(c) = false)

/* ID and purpose comments */
inv TestIdComments('The function ' + self.name + ' contains no ID comment - is it new?')
	: self.ownedComment->select(c : Comment | c._body.toString().startsWith('ID:'))->notEmpty() or hasNotToBeChecked(self)

inv TestPurposeComments('The function ' + self.name + ' contains no purpose comment - is it new?')
	: self.ownedComment->select(c : Comment | c._body.toString().startsWith('Purpose:'))->notEmpty() or hasNotToBeChecked(self)
					
def: getTopLevel : Set(Class)
	= getAllClasses
		->select(c : Class | c.getAssociations()->notEmpty() /* only classes with associations (i.e. no functional devices) */
			and c.ownedAttribute->select(p : Property | p.type.oclIsTypeOf(Class) /* only class-typed props (i.e. no ports (which are interface-typed)) */
				and p.aggregation = AggregationKind::composite /* only composite properties (i.e. "parent" end of the association) */
			)->notEmpty()) /* only classes with at least one matching property (i.e. do not select classes with no properties, as these will also match) */

def: getLeafClasses : Set(Class)
	= getAllClasses
		->select(c : Class | c.getAssociations()->notEmpty() /* see: getTopLevel - this time vice-versa */
			and c.ownedAttribute->select(p : Property | p.type.oclIsTypeOf(Class) 
				and p.aggregation = AggregationKind::composite
			)->isEmpty()) /* select classes that have NO "parent" ends of associations as properties */

/* Parent and child ports */
def: getParentPorts: Set(Port)
	= self.ownedAttribute
		->select(prop | prop.type.oclIsTypeOf(Class) and 
			prop.aggregation = AggregationKind::none
		)
			.type.oclAsType(Class).ownedPort->asSet()

def: getMatchingParentPort(me: Port): Port
	= if getParentPorts->select(parent | parent.name = me.name)->notEmpty()
		then getParentPorts->select(parent | parent.name = me.name)->asSequence()->first()
		else null
		endif

def: getChildPorts: Set(Port)
	= self.ownedAttribute
		->select(prop | prop.type.oclIsTypeOf(Class) and
		 	prop.aggregation = AggregationKind::composite
		 )
			.type.oclAsType(Class).ownedPort->asSet()

/* Operations defined by parent ports must include all operations that each child port uses */
/* I.e. test if there are child ports with operations not defined in parent ports */
def: portsNotDefinedInParent : Set(Port) = self.ownedPort->select(p : Port | /* self = child */
	not getParentPorts.getPortOperations.name->includesAll(p.getPortOperations.name)
)
inv HasPortsNotDefinedInParent('The ports '
	+ Model::setToString(portsNotDefinedInParent)
	+ ' of the function ' + self.name + ' are not defined in any of its parent functions!')
	: Model::asError( /* Do NOT throw an error if one of the following is true: */
		Model::getFunctionalDevices.name->includes(self.name) /* this class is not a functional device */
		or portsNotDefinedInParent->isEmpty() /* or it has no ports that are not defined in its parent classes*/
		or getTopLevel.name->includes(self.name) /* or is not a top-level-class */
		or hasNotToBeChecked(self) /* or it doesn't have to be checked */
	)

/* At least one operation of each parent port must exist in each child port */
/* I.e. fail, if all parent port operations are missing in the child port operations */
def: portsNotUsedInChildren : Set(Port) = self.ownedPort->select(p : Port | /* self = parent */
	getChildPorts.getPortOperations.name->excludesAll(p.getPortOperations.name)
)
inv HasPortsNotUsedInChildren('The ports '
	+ Model::setToString(portsNotUsedInChildren)
	+ ' of the function ' + self.name + ' are not used by any of its child functions.')
	: 	Model::getFunctionalDevices.name->includes(self.name) /* this class is not a functional device */
		or portsNotUsedInChildren->isEmpty()
		or getLeafClasses.name->includes(self.name)
		or hasNotToBeChecked(self)

def: portsWithDifferentDirection : Set(Port) 
	= self.ownedPort->select(p | getMatchingParentPort(p) <> null and getMatchingParentPort(p).isConjugated <> p.isConjugated)
inv HasParentPortsWithDifferentDirection('The ports '
	+ Model::setToString(portsWithDifferentDirection)
	+ ' of the function ' + self.name + ' have a different direction in the parent function!'
)
	: Model::asError(portsWithDifferentDirection->isEmpty() or hasNotToBeChecked(self))


/* Incoming and outgoing ports */
def: getIncomingPorts : Set (Port)
	= self.ownedPort
		->select(p | not p.isConjugated)

inv TestHasIncoming('The function ' + self.name + ' has no incoming ports.')
	: 	getIncomingPorts
		->notEmpty()
		or hasNotToBeChecked(self)
		
def: getOutgoingPorts : Set (Port)
	= self.ownedPort
		->select(p | p.isConjugated)

inv TestHasOutgoing('The function ' + self.name + ' has no outgoing ports.')
	: 	getOutgoingPorts
		->notEmpty()
		or hasNotToBeChecked(self)
		
context Port

def: getPortOperations: Set(Operation)
	= self.type.ownedElement.oclAsType(Operation)->asSet()

endpackage